/**
 * This file was automatically generated by the Mule Development Kit
 */
package com.angrygiant.mule.mqtt;

import org.apache.commons.lang.StringUtils;
import org.apache.log4j.Logger;
import org.eclipse.paho.client.mqttv3.*;
import org.mule.api.ConnectionExceptionCode;
import org.mule.api.annotations.Module;
import org.mule.api.ConnectionException;
import org.mule.api.annotations.Configurable;
import org.mule.api.annotations.Processor;
import org.mule.api.annotations.Source;
import org.mule.api.annotations.lifecycle.Start;
import org.mule.api.annotations.lifecycle.Stop;
import org.mule.api.annotations.param.Default;
import org.mule.api.annotations.param.Optional;
import org.mule.api.callback.SourceCallback;

import java.util.Date;
import java.util.Random;

/**
 * Generic module
 *
 * @author MuleSoft, Inc.
 */
@Module(name = "mqtt", schemaVersion = "1.0-SNAPSHOT")
public class MqttModule {
    private static final Logger logger = Logger.getLogger(MqttModule.class);

    public static final int MQTT_DEFAULT_PORT = 1883;
    public static final String MQTT_DEFAULT_HOST = "localhost";

    /**
     * Broker Host Name:  Host of the MQTT broker, defaults to 'localhost'
     */
    @Configurable
    @Optional
    @Default("localhost")
    private String brokerHostName = MQTT_DEFAULT_HOST;

    /**
     * Broker port number, defaults to 1883
     */
    @Configurable
    @Optional
    @Default("1883")
    private int brokerPort = MQTT_DEFAULT_PORT;

    /**
     * Client ID (required): client identifier for the broker
     */
    @Configurable
    private String clientId;

    /**
     * Clean Session - refer to Eclipse Paho documentation
     */
    @Configurable
    @Optional
    @Default("true")
    private boolean cleanSession;

    /**
     * Username to log into broker with
     */
    @Configurable
    @Optional
    private String username;

    /**
     * Password to log into broker with
     */
    @Configurable
    @Optional
    private String password;

    /**
     * Connection Timeout - refer to Eclipse Paho documentation
     */
    @Configurable
    @Optional
    @Default("30")
    private int connectionTimeout;

    /**
     * Last Will and Testimate Topic - refer to Eclipse Paho documentation
     */
    @Configurable
    @Optional
    private String lwtTopicName;

    /**
     * Last Will and Testimate Message - refer to Eclipse Paho documentation
     */
    @Configurable
    @Optional
    private String lwtMessage;

    /**
     * Last Will and Testimate QOS - refer to Eclipse Paho documentation
     */
    @Configurable
    @Optional
    @Default("2")
    private int lwtQos;

    /**
     * Last Will and Testimate Retention - refer to Eclipse Paho documentation
     */
    @Configurable
    @Optional
    @Default("false")
    private boolean lwtRetained;

    /**
     * Keep Alive Interval - refer to Eclipse Paho documentation
     */
    @Configurable
    @Optional
    @Default("60")
    private int keepAliveInterval;

    /**
     * File Persistence Location - directory on the machine where message persistence can be stored to disk.
     */
    @Configurable
    @Optional
    private String persistenceLocation;

    /**
     * Private variables not used by Mule directly
     */

    private MqttClient client;
    private MqttConnectOptions connectOptions = new MqttConnectOptions();

    /**
     * Initialize the connector by creating a client
     */
    @Start
    public void initialize() throws ConnectionException {
        this.client = connectClient(getClientId());
    }

    private MqttClient connectClient(String clientId) throws ConnectionException{
        String brokerUrl = "tcp://" + getBrokerHostName() + ":" + getBrokerPort();

        MqttDefaultFilePersistence filePersistence = null;
        if (getPersistenceLocation() != null || StringUtils.isNotBlank(getPersistenceLocation())) {
            try {
                filePersistence = new MqttDefaultFilePersistence(getPersistenceLocation());
            } catch (MqttPersistenceException e) {
                logger.error("Error creating file persistence for messages...persistence will be IGNORED!!!", e);
                filePersistence = null;
            }
        }

        setupConnectOptions();

        try {
            if (filePersistence == null) {
                return new MqttClient(brokerUrl, clientId);
            } else {
                return new MqttClient(brokerUrl, clientId, filePersistence);
            }
        } catch (MqttException e) {
            logger.error("Error creating client to MQTT broker:", e);
            throw new ConnectionException(ConnectionExceptionCode.UNKNOWN, null, "Mule has issues with the MQTT client", e);
        }
    }

    private void setupConnectOptions() {
        connectOptions.setCleanSession(isCleanSession());
        connectOptions.setConnectionTimeout(getConnectionTimeout());
        connectOptions.setKeepAliveInterval(getKeepAliveInterval());

        if (getPassword() != null || StringUtils.isNotBlank(getPassword())) {
            connectOptions.setPassword(getPassword().toCharArray());
        }

        connectOptions.setUserName(getUsername());

        //lwt
        if (StringUtils.isNotBlank(getLwtTopicName())) {
            logger.warn("FEATURE NOT YET IMPLEMENTED! Last Will and Testament will be ignored");
        }
    }

    /**
     * Stop the client prior to departure
     *
     * @throws MqttException
     */
    @Stop
    public void stopConnector() throws MqttException {
        if (this.client.isConnected()) {
            logger.info("Diconnecting from MQTT broker...");
            this.client.disconnect();
        }

        this.client = null;
        this.connectOptions = null;
    }

    /**
     * Publish processor - used to publish a message to a given topic on the MQTT broker.
     * <p/>
     * <p/>
     * {@sample.xml ../../../doc/mqtt-connector.xml.sample mqtt:publish}
     *
     * @param topicName topic to publish message to
     * @param payload   payload to publish message to
     * @param qos       qos level to use when publishing message
     * @return MqttMuleMessage instance
     */
    @Processor
    public MqttMuleMessage publish(String topicName, String payload, @Optional @Default("2") int qos) throws MqttException {
        logger.debug("Connecting to Broker...");
        if (!this.client.isConnected()) {
            this.client.connect();
            logger.info("Connected to " + getBrokerHostName() + " on port " + getBrokerPort() + " as " + getClientId());
        } else {
            logger.debug("Already connected to Broker");
        }

        if (qos < 0 || qos > 2) {
            logger.warn("QOS is invalid, setting to default value of 2");
            qos = 2;
        }

        logger.debug("Retrieving topic '" + topicName + "'");
        MqttTopic topic = this.client.getTopic(topicName);

        logger.debug("Preparing message...");
        MqttMessage message = new MqttMessage(payload.getBytes());
        message.setQos(qos);

        logger.debug("publishing message to broker...");
        MqttDeliveryToken token = topic.publish(message);

        logger.trace("Waiting for default timeout of 5minutes...");
        token.waitForCompletion(900000);

        return new MqttMuleMessage(message, topic);
    }

    /**
         * Publish processor - used to publish a message to a given topic on the MQTT broker.
         * <p/>
         * <p/>
         * {@sample.xml ../../../doc/mqtt-connector.xml.sample mqtt:subscribe}
         *
         * @param topicName topic to publish message to
         * @param qos       qos level to use when publishing message
         * @param callback       qos level to use when publishing message
         * @return
         */
    @Source
    public void subscribe(String topicName, @Optional @Default("2") int qos, final SourceCallback callback) throws ConnectionException {
        logger.info("Creating new client for topic subscription");
        String timestamp = Integer.toString(1);
        String subscriberId = "mulesubscriber" + timestamp;

        MqttClient subscriberClient = connectClient(subscriberId);

        try {
            subscriberClient.setCallback(new MqttTopicListener(subscriberClient, callback, topicName, qos));
            subscriberClient.connect(connectOptions);
            subscriberClient.subscribe(topicName, qos);
        } catch (MqttException e) {
            logger.error("MQTT Exceptions occurred subscribing", e);
            throw new ConnectionException(ConnectionExceptionCode.UNKNOWN, null, "Subscription Error", e);
        }

        logger.info("Done subscribing to topic " + topicName);
    }

    //Getters and Setters

    public String getBrokerHostName() {
        return brokerHostName;
    }

    public void setBrokerHostName(String brokerHostName) {
        this.brokerHostName = brokerHostName;
    }

    public int getBrokerPort() {
        return brokerPort;
    }

    public void setBrokerPort(int brokerPort) {
        this.brokerPort = brokerPort;
    }

    public String getClientId() {
        return clientId;
    }

    public void setClientId(String clientId) {
        this.clientId = clientId;
    }

    public boolean isCleanSession() {
        return cleanSession;
    }

    public void setCleanSession(boolean cleanSession) {
        this.cleanSession = cleanSession;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    public int getConnectionTimeout() {
        return connectionTimeout;
    }

    public void setConnectionTimeout(int connectionTimeout) {
        this.connectionTimeout = connectionTimeout;
    }

    public String getLwtTopicName() {
        return lwtTopicName;
    }

    public void setLwtTopicName(String lwtTopicName) {
        this.lwtTopicName = lwtTopicName;
    }

    public String getLwtMessage() {
        return lwtMessage;
    }

    public void setLwtMessage(String lwtMessage) {
        this.lwtMessage = lwtMessage;
    }

    public int getKeepAliveInterval() {
        return keepAliveInterval;
    }

    public void setKeepAliveInterval(int keepAliveInterval) {
        this.keepAliveInterval = keepAliveInterval;
    }

    public String getPersistenceLocation() {
        return persistenceLocation;
    }

    public void setPersistenceLocation(String persistenceLocation) {
        this.persistenceLocation = persistenceLocation;
    }

    public int getLwtQos() {
        return lwtQos;
    }

    public void setLwtQos(int lwtQos) {
        this.lwtQos = lwtQos;
    }

    public boolean isLwtRetained() {
        return lwtRetained;
    }

    public void setLwtRetained(boolean lwtRetained) {
        this.lwtRetained = lwtRetained;
    }
}
